name: _Reusable Build Containers (internal use only)

on:
  workflow_call:
    inputs:
      container_type:
        description: 'Type of container to build'
        required: true
        type: string  # 'core', 'full', 'dev', 'custom', 'experiment'

      # Common inputs
      build_platforms:
        description: 'Platforms to build for'
        required: false
        default: 'linux/amd64,linux/arm64'
        type: string

      image_prefix:
        description: 'Image prefix (e.g., "sst", "sst-dev")'
        required: true
        type: string

      tag_suffix:
        description: 'Tag suffix for the built images'
        required: true
        type: string

      # SST-specific inputs
      sst_version:
        description: 'SST version (for release builds)'
        required: false
        type: string

      mpich_version:
        description: 'MPICH version'
        required: false
        default: '4.0.2'
        type: string

      # Custom/Experiment specific
      sst_core_repo:
        description: 'SST-core repository URL'
        required: false
        type: string

      sst_core_ref:
        description: 'SST-core reference'
        required: false
        type: string

      sst_elements_repo:
        description: 'SST-elements repository URL'
        required: false
        type: string

      sst_elements_ref:
        description: 'SST-elements reference'
        required: false
        type: string

      experiment_name:
        description: 'Experiment name (for experiment builds)'
        required: false
        type: string

      base_image:
        description: 'Base image for experiment builds'
        required: false
        type: string

      # Build configuration
      containerfile_path:
        description: 'Path to Containerfile'
        required: false
        default: 'Containerfiles/Containerfile'
        type: string

      docker_context:
        description: 'Docker build context'
        required: false
        default: 'Containerfiles'
        type: string

      build_target:
        description: 'Docker build target'
        required: false
        type: string

      # Advanced options
      force_rebuild:
        description: 'Force rebuild even if images exist'
        required: false
        default: false
        type: boolean

      ignore_cache:
        description: 'Ignore build cache'
        required: false
        default: false
        type: boolean

    outputs:
      built_images:
        description: 'JSON array of built image tags'
        value: ${{ jobs.collect-images.outputs.built_images }}

      manifest_tag:
        description: 'Fat manifest tag'
        value: ${{ jobs.create-manifest.outputs.manifest_tag }}

      build_successful:
        description: 'Whether build was successful'
        value: ${{ jobs.create-manifest.outputs.manifest_tag != '' }}

env:
  REGISTRY: ghcr.io
  BUILD_NCPUS: 4

jobs:
  prepare-platforms:
    runs-on: ubuntu-latest
    outputs:
      platforms: ${{ steps.setup.outputs.platforms }}
    steps:
      - name: Setup platforms
        id: setup
        run: |
          PLATFORMS="${{ inputs.build_platforms }}"
          echo "platforms=$(echo "$PLATFORMS" | jq -R -c 'split(",")' )" >> $GITHUB_OUTPUT

  build-containers:
    runs-on: ${{ matrix.platform == 'linux/arm64' && 'ubuntu-24.04-arm' || 'ubuntu-latest' }}
    needs: [prepare-platforms]
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        platform: ${{ fromJson(needs.prepare-platforms.outputs.platforms) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Cache MPICH tarball
        id: cache-mpich
        if: inputs.mpich_version != ''
        uses: actions/cache@v3
        with:
          path: Containerfiles/mpich-${{ inputs.mpich_version }}.tar.gz
          key: mpich-${{ inputs.mpich_version }}

      - name: Download MPICH source
        if: inputs.mpich_version != '' && steps.cache-mpich.outputs.cache-hit != 'true'
        working-directory: Containerfiles
        run: |
          echo "Downloading MPICH ${{ inputs.mpich_version }}..."
          wget https://www.mpich.org/static/downloads/${{ inputs.mpich_version }}/mpich-${{ inputs.mpich_version }}.tar.gz --no-check-certificate

      - name: List available source files
        if: inputs.mpich_version != ''
        working-directory: Containerfiles
        run: |
          if [ ! -f "mpich-${{ inputs.mpich_version }}.tar.gz" ]; then
            echo "ERROR: MPICH file mpich-${{ inputs.mpich_version }}.tar.gz not found"
            exit 1
          fi
          echo "MPICH source file validated"

      - name: Cache SST sources
        id: cache-sst
        if: inputs.sst_version != ''
        uses: actions/cache@v3
        with:
          path: |
            Containerfiles/sstcore-${{ inputs.sst_version }}.tar.gz
            Containerfiles/sstelements-${{ inputs.sst_version }}.tar.gz
          key: sst-sources-${{ inputs.sst_version }}

      - name: Download SST sources
        if: inputs.sst_version != '' && steps.cache-sst.outputs.cache-hit != 'true'
        working-directory: Containerfiles
        run: |
          echo "Downloading SST ${{ inputs.sst_version }} sources..."
          wget https://github.com/sstsimulator/sst-core/releases/download/v${{ inputs.sst_version }}_Final/sstcore-${{ inputs.sst_version }}.tar.gz --no-check-certificate
          wget https://github.com/sstsimulator/sst-elements/releases/download/v${{ inputs.sst_version }}_Final/sstelements-${{ inputs.sst_version }}.tar.gz --no-check-certificate

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract platform info
        id: platform
        run: |
          PLATFORM="${{ matrix.platform }}"
          ARCH="${PLATFORM##*/}"
          echo "arch=$ARCH" >> $GITHUB_OUTPUT
          echo "platform_safe=${PLATFORM//\//-}" >> $GITHUB_OUTPUT

      - name: Prepare container tags
        id: tags
        run: |
          ARCH="${{ steps.platform.outputs.arch }}"

          # Tag generation based on container type
          case "${{ inputs.container_type }}" in
            "core"|"full")
              TEMP_TAG="${{ env.REGISTRY }}/${{ inputs.image_prefix }}-${{ inputs.container_type }}:${{ inputs.tag_suffix }}-${ARCH}"
              ;;
            "dev"|"custom")
              TEMP_TAG="${{ env.REGISTRY }}/${{ inputs.image_prefix }}:${{ inputs.tag_suffix }}-${ARCH}"
              ;;
            "experiment")
              TEMP_TAG="${{ env.REGISTRY }}/${{ inputs.image_prefix }}/${{ inputs.experiment_name }}:${{ inputs.tag_suffix }}-${ARCH}"
              ;;
            *)
              TEMP_TAG="${{ env.REGISTRY }}/${{ inputs.image_prefix }}:${{ inputs.tag_suffix }}-${ARCH}"
              ;;
          esac

          echo "temp_tag=${TEMP_TAG}" >> $GITHUB_OUTPUT
          echo "Building: ${TEMP_TAG}"

      - name: Build and push container
        uses: docker/build-push-action@v5
        with:
          context: ${{ inputs.docker_context }}
          file: ${{ inputs.containerfile_path }}
          target: ${{ inputs.build_target }}
          platforms: ${{ matrix.platform }}
          build-args: |
            ${{ (inputs.container_type == 'core' || inputs.container_type == 'full') && inputs.sst_version && format('SSTver={0}', inputs.sst_version) || '' }}
            ${{ inputs.mpich_version && format('mpich={0}', inputs.mpich_version) || '' }}
            ${{ inputs.sst_core_repo && format('SSTrepo={0}', inputs.sst_core_repo) || '' }}
            ${{ inputs.sst_core_ref && format('tag={0}', inputs.sst_core_ref) || '' }}
            ${{ inputs.sst_elements_repo && format('SSTElementsRepo={0}', inputs.sst_elements_repo) || '' }}
            ${{ inputs.sst_elements_ref && format('elementsTag={0}', inputs.sst_elements_ref) || '' }}
            ${{ inputs.base_image && format('BASE_IMAGE={0}', inputs.base_image) || '' }}
            NCPUS=${{ env.BUILD_NCPUS }}
          labels: |
            com.github.sha=${{ github.sha }}
            com.github.workflow=${{ github.workflow }}
            com.github.run_id=${{ github.run_id }}
            com.github.run_number=${{ github.run_number }}
            com.github.repository=${{ github.repository }}
            com.github.ref_name=${{ github.ref_name }}
            com.container.type=${{ inputs.container_type }}
          tags: ${{ steps.tags.outputs.temp_tag }}
          push: true
          cache-from: type=gha,scope=${{ inputs.container_type }}-${{ inputs.tag_suffix }}-${{ steps.platform.outputs.arch }}
          cache-to: type=gha,mode=max,scope=${{ inputs.container_type }}-${{ inputs.tag_suffix }}-${{ steps.platform.outputs.arch }}

      - name: Output built image
        run: |
          echo "Built image: ${{ steps.tags.outputs.temp_tag }}"

      - name: Upload MPICH artifact (for caching across jobs)
        uses: actions/upload-artifact@v4
        if: inputs.mpich_version != '' && steps.cache-mpich.outputs.cache-hit != 'true'
        with:
          name: mpich-${{ inputs.mpich_version }}
          path: Containerfiles/mpich-${{ inputs.mpich_version }}.tar.gz
          retention-days: 10

      - name: Check if SST sources artifact exists
        id: check-sst-artifact
        if: inputs.sst_version != '' && steps.cache-sst.outputs.cache-hit != 'true'
        run: |
          # Check if artifact already exists from another job
          if gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts --paginate | jq -r '.artifacts[].name' | grep -q "^sst-sources-${{ inputs.sst_version }}$"; then
            echo "artifact_exists=true" >> $GITHUB_OUTPUT
            echo "SST sources artifact already exists, skipping upload"
          else
            echo "artifact_exists=false" >> $GITHUB_OUTPUT
            echo "SST sources artifact does not exist, will upload"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload SST sources artifact
        uses: actions/upload-artifact@v4
        if: inputs.sst_version != '' && steps.cache-sst.outputs.cache-hit != 'true' && steps.check-sst-artifact.outputs.artifact_exists != 'true'
        with:
          name: sst-sources-${{ inputs.sst_version }}
          path: |
            Containerfiles/sstcore-${{ inputs.sst_version }}.tar.gz
            Containerfiles/sstelements-${{ inputs.sst_version }}.tar.gz
          retention-days: 10

  collect-images:
    runs-on: ubuntu-latest
    needs: [build-containers]
    if: needs.build-containers.result == 'success'
    outputs:
      built_images: ${{ steps.collect-all.outputs.built_images }}
    steps:
      - name: Collect all built images
        id: collect-all
        run: |
          PLATFORMS="${{ inputs.build_platforms }}"

          # Build JSON array of all architecture-specific images
          IFS=',' read -ra PLATFORM_ARRAY <<< "$PLATFORMS"
          IMAGES="[]"

          for platform in "${PLATFORM_ARRAY[@]}"; do
            ARCH="${platform#linux/}"

            case "${{ inputs.container_type }}" in
              "core"|"full")
                TEMP_TAG="${{ env.REGISTRY }}/${{ inputs.image_prefix }}-${{ inputs.container_type }}:${{ inputs.tag_suffix }}-${ARCH}"
                ;;
              "dev"|"custom")
                TEMP_TAG="${{ env.REGISTRY }}/${{ inputs.image_prefix }}:${{ inputs.tag_suffix }}-${ARCH}"
                ;;
              "experiment")
                TEMP_TAG="${{ env.REGISTRY }}/${{ inputs.image_prefix }}/${{ inputs.experiment_name }}:${{ inputs.tag_suffix }}-${ARCH}"
                ;;
              *)
                TEMP_TAG="${{ env.REGISTRY }}/${{ inputs.image_prefix }}:${{ inputs.tag_suffix }}-${ARCH}"
                ;;
            esac

            IMAGES=$(echo "$IMAGES" | jq -c --arg tag "$TEMP_TAG" '. += [$tag]')
          done

          echo "built_images=$IMAGES" >> $GITHUB_OUTPUT
          echo "Collected images: $IMAGES"

  create-manifest:
    runs-on: ubuntu-latest
    needs: [collect-images]
    if: needs.collect-images.result == 'success'
    permissions:
      contents: read
      packages: write
    outputs:
      manifest_tag: ${{ steps.manifest.outputs.manifest_tag }}
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create multi-architecture manifest
        id: manifest
        run: |
          PLATFORMS="${{ inputs.build_platforms }}"

          # Determine final manifest tag based on container type
          case "${{ inputs.container_type }}" in
            "core"|"full")
              MANIFEST_TAG="${{ env.REGISTRY }}/${{ inputs.image_prefix }}-${{ inputs.container_type }}:${{ inputs.tag_suffix }}"
              ;;
            "dev"|"custom")
              MANIFEST_TAG="${{ env.REGISTRY }}/${{ inputs.image_prefix }}:${{ inputs.tag_suffix }}"
              ;;
            "experiment")
              MANIFEST_TAG="${{ env.REGISTRY }}/${{ inputs.image_prefix }}/${{ inputs.experiment_name }}:${{ inputs.tag_suffix }}"
              ;;
            *)
              MANIFEST_TAG="${{ env.REGISTRY }}/${{ inputs.image_prefix }}:${{ inputs.tag_suffix }}"
              ;;
          esac

          echo "Creating manifest: ${MANIFEST_TAG}"

          # Collect architecture-specific images
          IFS=',' read -ra PLATFORM_ARRAY <<< "$PLATFORMS"
          MANIFESTS=""

          for platform in "${PLATFORM_ARRAY[@]}"; do
            ARCH="${platform#linux/}"
            TEMP_TAG="${MANIFEST_TAG}-${ARCH}"
            if docker manifest inspect "${TEMP_TAG}" >/dev/null 2>&1; then
              MANIFESTS="$MANIFESTS ${TEMP_TAG}"
            fi
          done

          if [ -n "$MANIFESTS" ]; then
            echo "Creating multi-arch manifest: ${MANIFEST_TAG}"
            docker buildx imagetools create --tag "${MANIFEST_TAG}" $MANIFESTS
            echo "manifest_tag=${MANIFEST_TAG}" >> $GITHUB_OUTPUT
          else
            echo "ERROR: No images found for manifest creation"
            exit 1
          fi
